8）方法的接收者 
Go 中，用接收者（receiver）来定义方法，类似于C++的成员函数
type Integer int 
func (a Integer) Less(b Integer) bool {
    return a < b
}
但是有趣的是，可以为变量也绑定专门的方法。
| 项目     | 函数（Function）            | 方法（Method）                        |
| ------ | ----------------------- | --------------------------------- |
| 是否有接收者 | ? 没有接收者                 | ? 有接收者（如 `func (p *Plane) Fly()`） |
| 调用方式   | `FunctionName(args...)` | `instance.MethodName(args...)`    |
| 是否绑定对象 | 否，只和包关联                 | 是，绑定到某种类型                         |
| 是否可以重名 | ?（在同一个包内不能重名）           | ? 不同类型的方法可以同名                     |
“对象在执行操作”
&
“函数对对象执行操作”

9）结构体 struct
golang结构体没有public,private等字段，是通过成员的大小写区分权限的。
大写的结构体成员，别的包可以访问，小写的成员不可被别的包访问，也就无法被初始化。
Rect的成员都为小写，所以别的包无法访问，但是可以通过定义大写的方法，提供给别的包访问
->那么如何初始化这个 Rect 结构体呢？
大写的构造函数 + 大写的方法 -> 另一个包当中 import 之后调用
func (结构体指针/ 值 ) 方法名(方法参数列表) 方法返回值{
    //方法内部实现
}
如果两个结构体类型，顺序相同，且不含有无法比较类型(slice, map),则可以进行比较

10）关于 CPP 和 GO 在封装上的不同之处
| 特性          | Go             | C++              |
| ----------- | -------------- | ---------------- |
| 非公开字段能否初始化  | ? 不可以，除非通过构造函数 | ? 可以（通过构造函数）     |
| 默认封装粒度      | 基于标识符大小写（包级别）  | 明确的访问修饰符控制（类级别）  |
| 使用字面量初始化的限制 | 有：只能初始化导出字段    | 无：可以构造对象，字段访问再控制 |
CPP:
只要 #include 引入了相应的头文件，且构造函数是 public 的，即使类的成员变量是 private 或 protected，也可以在外部进行对象的初始化。
成员变量的访问权限控制并不影响对象的构造，只影响成员变量的访问权限

GO:
字段的访问权限是由字段首字母的大小写决定的。小写字段是私有的，无法在外部包中直接访问，甚至无法通过结构体字面量进行初始化。
如果字段是小写（私有字段），那么就无法在外部直接访问或初始化这些字段。必须通过构造函数来初始化，或者通过提供的公开方法来访问它们。


11）组合（golang的精髓）
//匿名指针组合
type DerivePoint struct {
	*Base
}
func (derivep *DerivePoint) Foo() bool {
	fmt.Println("this is DerivePoint Foo")
	fmt.Println("inherit base ,name is ", derivep.Name)
	return true
}
->实际调用：显示初始化基类指针
dr := &DerivePoint{Base: &Base{Name: "base"}}
dr.Foo()