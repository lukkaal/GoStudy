1）线程模型和协程模型
Go 的调度模型是 GMP 模型：
| 概念  | 作用                         |
| --- | -------------------------- |
| `G` | goroutine，用户级线程（协程）        |
| `M` | machine，内核线程（真正运行在 CPU 上的） |
| `P` | processor，执行上下文，包含可运行 G 队列 |
goroutine 由调度器将多个 G 绑定到多个 M 上运行，
M 的数量可以等于、少于或多于 G 的数量。
Go 的运行时默认会创建多个线程（M），并由 Go 调度器将 goroutine 分发上去运行。

->线程会一直执行就绪队列的协程，而协程(因为是用户态)直接接受调度器的调度可以被挂起

那么对于协程的epoll：
线程模型中，主线程 epoll_wait 后由自己或工作线程执行回调处理逻辑；
协程模型中，调度器在 epoll_wait 后唤醒挂起的协程，协程继续自己的顺序逻辑。
| 对比点               | 线程 + epoll                   | 协程 + epoll（如 Go / asyncio）     |
| ----------------- | ---------------------------- | ------------------------------ |
| 谁调用 `epoll_wait`？ | 通常是主线程                       | 协程运行时系统的调度器线程                  |
| 就绪事件来了以后？         | 主线程从 `epoll` 拿到事件，**执行回调函数** | 调度器拿到事件，**唤醒对应挂起的协程**          |
| 执行代码方式            | 回调风格，事件驱动，代码碎片化              | 顺序逻辑，像同步代码一样书写                 |
| 用户视角代码结构          | `on_read`, `on_write`, 状态机   | `conn.read()`, `await`，像阻塞函数一样 |
| 切换执行上下文           | 切线程、系统调用开销大                  | 切协程、用户态切换，极小开销                 |
| 性能/扩展性            | 好，但有复杂度上限                    | 极高，更易扩展和维护                     |

go func() {
    conn, _ := listener.Accept()
    buf := make([]byte, 1024)
    n, _ := conn.Read(buf)  // 会阻塞协程，但不会阻塞线程
    fmt.Println(string(buf[:n]))
}()
线程模型是：“事件来了 → 主线程执行逻辑”。
协程模型是：“事件来了 → 唤醒之前挂起的协程 → 协程继续执行”。

如何实现挂起和回调？
调度器将协程挂起并记录它依赖的 fd->
epoll 检测到该 fd 就绪；
调度器在 epoll 返回后，查找依赖于这些 fd 的协程，并将它们重新调度到运行队列；
协程被唤醒，从挂起的位置继续执行。

I/O 复用本质上是底层机制（如 epoll、kqueue），与线程或协程无直接冲突。区别在于——
线程 + I/O 复用：让少量线程同时处理大量连接；
协程 + I/O 复用：让协程调度器感知 I/O 就绪，挂起/唤醒对应协程，实现用户态并发逻辑流的切换。
所以它们的区别本质是：调度维度不同（线程级 vs 协程级），抽象层次不同（系统级 vs 用户级）。